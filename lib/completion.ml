(*open Fix.Indexing*)
(*open Utils*)

(* Construct the LRC Completion automaton *)

module Make(Info : Info.S)(Lrc: Lrc.S with module Info := Info) =
struct
  (*open Info*)

  (* Find all the reachable reduction paths and items that go through an Lrc
     state. *)
  (*type item_path = {
    isuffix: Lrc.n index list;
    iposition: int;
    iproduction: Production.t;
    ilookaheads: Terminal.set;
  }

  type goto_path = {
    source: Lrc.n index;
    target: Lrc.n index;
    suffix: Lrc.n index list;
    production: Production.t;
    lookaheads: Terminal.set;
  }

  let rcount = ref 0
  let icount = ref 0
  let items = Vector.make Lrc.n []
  let reductions = Vector.make Lrc.n []

  let () =
    let rec simulate_reduction item source =
      incr icount;
      Vector.set_cons items source item;
      if item.iposition = 0 then
        IndexSet.iter (fun target ->
        let path = {
          state;
          suffix = item.isuffix;
          production = item.iproduction;
          lookaheads = item.ilookaheads;
        } in
        incr rcount;
        Vector.set_cons reductions source path;

          ) (Lrc.successors source);
      else
        let item' = {
          item with
          isuffix = source :: item.isuffix;
          iposition = item.iposition - 1;
        } in
        IndexSet.iter
          (simulate_reduction item')
          (Lrc.predecessors source)
    in
    Index.iter Lrc.n (fun lrc ->
        let lr1 = Lrc.lr1_of_lrc lrc in
        let lookaheads = Lrc.lookahead lrc in
        IndexSet.iter (fun red ->
            let ilookaheads =
              Terminal.intersect (Reduction.lookaheads red) lookaheads
            in
            if not (IndexSet.is_empty ilookaheads) then (
              let iproduction = Reduction.production red in
              simulate_reduction {
                isuffix = [];
                iposition = Production.length iproduction;
                iproduction;
                ilookaheads;
              } lrc
            )
          ) (Reduction.from_lr1 lr1)
      )*)

  (*let () =
    Printf.eprintf
      "Reachable reduction paths are generated by a grammar with \
       %d non-terminals (%d symbols) and %d rules (%d items)\n"
      (cardinal Lrc.n) !rcount !icount*)

  (* Approximate the radius of convergence of the different
     (generating functions of) states. *)

  (* Step 1: finding transitions that can be taken by consuming only a finite
             amount of symbols.  *)
  (*module Finite = struct

    (* For a state to be finite, all of its paths must be.
       Count the number of non-finite paths. *)
    let states = Vector.map List.length reductions

    let () =
      Vector.iteri (fun i paths ->
          match paths with
          | [] ->
        ) paths
  end

  (*type state =
    | Suffix of {
        goto: Lrc.n list;
        top: Lrc.n;
        lookaheads: Terminal.set;
      }
    | Reduce of {
        goto: Lrc.n list;
        top: Lrc.n;
        lookaheads: Terminal.set;
        lhs: Nonterminal.n;
        dot: int;
      }*)

  (*type monomial = {
    degree: int;

  }

    let monomials = Vector.map*)
  *)
end
