open Fix.Indexing
open Utils
open Misc
open Info

let builtin = function
  | "AMPERAMPER"             -> "&&"
  | "AMPERSAND"              -> "&"
  | "AND"                    -> "and"
  | "AS"                     -> "as"
  | "ASSERT"                 -> "assert"
  | "BACKQUOTE"              -> "`"
  | "BANG"                   -> "!"
  | "BAR"                    -> "|"
  | "BARBAR"                 -> "||"
  | "BARRBRACKET"            -> "|]"
  | "BEGIN"                  -> "begin"
  | "CHAR"                   -> "'a'"
  | "CLASS"                  -> "class"
  | "COLON"                  -> ":"
  | "COLONCOLON"             -> "::"
  | "COLONEQUAL"             -> ":="
  | "COLONGREATER"           -> ":>"
  | "COMMA"                  -> ","
  | "CONSTRAINT"             -> "constraint"
  | "DO"                     -> "do"
  | "DONE"                   -> "done"
  | "DOT"                    -> "."
  | "DOTDOT"                 -> ".."
  | "DOWNTO"                 -> "downto"
  | "EFFECT"                 -> "effect"
  | "ELSE"                   -> "else"
  | "END"                    -> "end"
  | "EOF"                    -> ""
  | "EQUAL"                  -> "="
  | "EXCEPTION"              -> "exception"
  | "EXTERNAL"               -> "external"
  | "FALSE"                  -> "false"
  | "FLOAT"                  -> "42.0"
  | "FOR"                    -> "for"
  | "FUN"                    -> "fun"
  | "FUNCTION"               -> "function"
  | "FUNCTOR"                -> "functor"
  | "GREATER"                -> ">"
  | "GREATERRBRACE"          -> ">}"
  | "GREATERRBRACKET"        -> ">]"
  | "IF"                     -> "if"
  | "IN"                     -> "in"
  | "INCLUDE"                -> "include"
  | "INFIXOP0"               -> "!="
  | "INFIXOP1"               -> "@"
  | "INFIXOP2"               -> "+!"
  | "INFIXOP3"               -> "land"
  | "INFIXOP4"               -> "**"
  | "DOLLAR"                 -> "$"
  | "LESSLBRACKET"           -> "<["
  | "RBRACKETGREATER"        -> "]>"
  | "DOTOP"                  -> ".+"
  | "LETOP"                  -> "let*"
  | "ANDOP"                  -> "and*"
  | "INHERIT"                -> "inherit"
  | "INITIALIZER"            -> "initializer"
  | "INT"                    -> "42"
  | "LABEL"                  -> "~label:"
  | "LAZY"                   -> "lazy"
  | "LBRACE"                 -> "{"
  | "LBRACELESS"             -> "{<"
  | "LBRACKET"               -> "["
  | "LBRACKETBAR"            -> "[|"
  | "LBRACKETLESS"           -> "[<"
  | "LBRACKETGREATER"        -> "[>"
  | "LBRACKETPERCENT"        -> "[%"
  | "LBRACKETPERCENTPERCENT" -> "[%%"
  | "LESS"                   -> "<"
  | "LESSMINUS"              -> "<-"
  | "LET"                    -> "let"
  | "LIDENT"                 -> "lident"
  | "LPAREN"                 -> "("
  | "LBRACKETAT"             -> "[@"
  | "LBRACKETATAT"           -> "[@@"
  | "LBRACKETATATAT"         -> "[@@@"
  | "MATCH"                  -> "match"
  | "METHOD"                 -> "method"
  | "MINUS"                  -> "-"
  | "MINUSDOT"               -> "-."
  | "MINUSGREATER"           -> "->"
  | "MODULE"                 -> "module"
  | "MUTABLE"                -> "mutable"
  | "NEW"                    -> "new"
  | "NONREC"                 -> "nonrec"
  | "OBJECT"                 -> "object"
  | "OF"                     -> "of"
  | "OPEN"                   -> "open"
  | "OPTLABEL"               -> "?label:"
  | "OR"                     -> "or"
  | "PARSER"                 -> "parser"
  | "PERCENT"                -> "%"
  | "PLUS"                   -> "+"
  | "PLUSDOT"                -> "+."
  | "PLUSEQ"                 -> "+="
  | "PREFIXOP"               -> "!+"
  | "PRIVATE"                -> "private"
  | "QUESTION"               -> "?"
  | "QUOTE"                  -> "'"
  | "RBRACE"                 -> "}"
  | "RBRACKET"               -> "]"
  | "REC"                    -> "rec"
  | "RPAREN"                 -> ")"
  | "SEMI"                   -> ";"
  | "SEMISEMI"               -> ";;"
  | "HASH"                   -> "#"
  | "HASHOP"                 -> "##"
  | "SIG"                    -> "sig"
  | "STAR"                   -> "*"
  | "STRING"                 -> "\"hello\""
  | "QUOTED_STRING_EXPR"     -> "{%hello|world|}"
  | "QUOTED_STRING_ITEM"     -> "{%%hello|world|}"
  | "STRUCT"                 -> "struct"
  | "THEN"                   -> "then"
  | "TILDE"                  -> "~"
  | "TO"                     -> "to"
  | "TRUE"                   -> "true"
  | "TRY"                    -> "try"
  | "TYPE"                   -> "type"
  | "UIDENT"                 -> "UIdent"
  | "UNDERSCORE"             -> "_"
  | "VAL"                    -> "val"
  | "VIRTUAL"                -> "virtual"
  | "WHEN"                   -> "when"
  | "WHILE"                  -> "while"
  | "WITH"                   -> "with"
  | "COMMENT"                -> "(*comment*)"
  | "DOCSTRING"              -> "(**documentation*)"
  | "EOL"                    -> "\n"
  | "METAOCAML_ESCAPE"       -> ".~"
  | "METAOCAML_BRACKET_OPEN" -> ".<"
  | "METAOCAML_BRACKET_CLOSE" -> ">."
  | "MOD"           -> "mod"
  | "EXCLAVE"       -> "exclave_"
  | "GLOBAL"        -> "global_"
  | "KIND_ABBREV"   -> "kind_abbrev_"
  | "KIND_OF"       -> "kind_of_"
  | "LOCAL"         -> "local_"
  | "ONCE"          -> "once_"
  | "OVERWRITE"     -> "overwrite_"
  | "STACK"         -> "stack_"
  | "UNIQUE"        -> "unique_"
  | "LBRACKETCOLON" -> "[:"
  | "HASH_SUFFIX"   -> "#"
  | "HASH_INT"      -> "#1l"
  | "HASH_FLOAT"    -> "#1.0"
  | "HASHLPAREN"    -> "#("
  | "AT"            -> "@"
  | "ATAT"          -> "@@"
  | "COLONRBRACKET" -> ":]"
  | "DOTHASH"       -> ".#"
  | "HASHLBRACE"    -> "#{"
  | "error" | "#" as x       -> x ^ "(*FIXME: Should not happen)"
  | _ -> raise Not_found

let for_grammar (grammar : _ Info.grammar) custom =
  let (module G) = Info.raw grammar in
  let unknown = ref [] in
  let table =
    Vector.init (Terminal.cardinal grammar) @@
    fun t ->
    let name = Terminal.to_string grammar t in
    let attributes = G.Terminal.attributes (G.Terminal.of_int (Index.to_int t)) in
    match List.assoc_opt name custom with
    | Some txt -> txt
    | None ->
      match List.find_opt (fun attr -> G.Attribute.label attr = "name") attributes with
      | Some attr -> G.Attribute.payload attr
      | None ->
        match builtin name with
        | txt -> txt
        | exception Not_found ->
          push unknown name; name
  in
  match !unknown with
  | [] -> table
  | xs ->
    prerr_endline "Unknown terminals (pass --terminal 'name=text'):";
    List.iter prerr_endline xs;
    exit 1
