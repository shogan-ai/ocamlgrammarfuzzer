# OCaml Grammar Fuzzer

> **ocamlgrammarfuzzer** is a random‑sentence generator for the OCaml (and OxCaml) grammar.
> It can be used to stress‑test tools such as **ocamlformat**, the OCaml parser, or any
> downstream program that consumes OCaml source code.

The tool ships a built‑in grammar for the standard OCaml language, a grammar for
the OxCaml dialect, and also supports loading a grammar from a `.cmly` file
generated by Menhir.  Sentences can be printed directly, or they can be checked
against `ocamlformat` to obtain a detailed classification of failures.

---  

## Overview

The core algorithm builds grammatical *derivations* on a Menhir automaton.

The generation can be controlled:
* **Focused generation** – `--focus` lets you bias the generator toward
  particular grammatical constructions.
* **Avoid / weight** – Use `--avoid` to forbid productions and `--weight`
  to increase or decrease their probability.
* **Exhaustive mode** – With `--exhaust` the fuzzer enumerates a
  deterministic set that covers *all* reachable productions
  (subject to weight > 0).
* **Comments** – Fake comments can be inserted (`--comments`).

By default, the sentences are simply printed, but in *check mode* 
(`--ocamlformat-check`) they are fed to `ocamlformat`.  Failures are classified as lexer errors, syntax errors, comment handling errors, invariant errors (when rejected by semantic actions), and internal errors. See **Error classification**.

---  

## Installation 

TODO: add opam package

``` bash
opam pin add ocamlgrammarfuzzer https://github.com/shogan-ai/ocamlgrammarfuzzer.git 
```

## Building from sources

The project is a standard OCaml executable. It depends on `dune` for building, `menhir` for loading grammars and, at runtime, on the `ocamlformat` binary in **check mode**.

```bash
# Get the source
git clone https://github.com/shogan-ai/ocamlgrammarfuzzer.git
cd ocamlgrammarfuzzer
# Build the executable
dune build ocamlgrammarfuzzer
```

## Running the fuzzer

When installed, the executable is called `ocamlgrammarfuzzer`.
The most basic invocation prints a single sentence:

```bash
$ ocamlgrammarfuzzer
let x = 42
```

### Typical usage patterns

* **Generate many sentences**

  ```bash
  ocamlgrammarfuzzer --count 500 --length 120
  ```
  produce 500 sentences (one per line) of at most 120 tokens each (by default, 1 sentence of at most 100 tokens).

* **Target a specific entry point** (e.g. to generate only .mli files)

  ```bash
  ocamlgrammarfuzzer --entrypoint interface --count 200
  ```

* **Add fake comments** (useful when testing comment handling)

  ```bash
  ocamlgrammarfuzzer --comments --count 100
  ```

* **Control randomness**

  ```bash
  ocamlgrammarfuzzer --seed 42 --count 50
  ```

* **Focus on a pattern**

  ```bash
  ocamlgrammarfuzzer --focus "seq_expr" # generate enough sentences to cover all situations in which `seq_expr` appears
  ```

* **Avoid a construction**

  ```bash
  ocamlgrammarfuzzer --avoid 'let_binding_body: val_ident'  # avoid the punned let construction
  ```

* **Exhaustive enumeration** (deterministic, produce a huge number of sentences, `--count` is ignored)

  ```bash
  ocamlgrammarfuzzer --exhaust
  ```

* **Use a custom grammar**

  ```bash
  ocamlgrammarfuzzer --cmly my_grammar.cmly # ignore if you provide a .cmly file
  ```

---  

## Command‑line options

Below is the complete list (the driver file already contains the help strings).

| Option                       | Argument            | Meaning                                                               |
|------------------------------|---------------------|-----------------------------------------------------------------------|
| `--count`                    | `<int>`             | Number of sentences to generate (default=1).                          |
| `--length`                   | `<int>`             | Approximate number of tokens per sentence (default=100).              |
| `--seed`                     | `<int>`             | Random seed (default=system time).                                    |
| `--entrypoint`               | `<symbol>`          | Generate sentences starting from this non‑terminal.                   |
| `--weight`                   | `<float> <pattern>` | Multiply the weight of productions matching `<pattern>` by `<float>`. |
| `--avoid`                    | `<pattern>`         | Set weight=0 for productions matching `<pattern>`.                    |
| `--focus`                    | `<pattern>`         | Bias generation toward productions matching `<pattern>`.              |
| `--exhaust`                  | –                   | Deterministic exhaustive generation (ignores `--count`).              |
| `--ocamlformat`              | `<path>`            | Customize ocamlformat command to use in check mode.                   |
| `--oxcaml`                   | –                   | Use the OxCaml dialect instead of the standard OCaml grammar.         |
| `--lr1`                      | –                   | Interpret builtin grammars as LR(1) instead of LALR.                  |
| `--cmly`                     | `<path.cmly>`       | Load a grammar from a Menhir `.cmly` file.                            |
| `--comments`                 | –                   | Insert fake comments in the generated code.                           |
| `--print-entrypoint`         | –                   | When printing, prefix each sentence with the entrypoint name.         |
| `--terminal`                 | `<NAME>=<TEXT>`     | Override the printed text for a terminal symbol.                      |
| `--jobs`                     | `<int>`             | Parallel `ocamlformat` processes (default=8).                         |
| `--batch-size`               | `<int>`             | Number of files per `ocamlformat` batch (default=400).                |
| `--ocamlformat-check`        | –                   | Run in *check mode* (see below).                                      |
| `--save-report-to`           | `<path>`            | Where to write the Markdown report (default=stdout).                  |
| `--max-report`               | `<int>`             | Maximum derivations per error message (default=20).                   |
| `--save-successful-to`       | `<path>`            | Save successful sentences (no errors) to a file.                      |
| `--save-lexer-errors-to`     | `<path>`            | Save sentences that caused lexer errors.                              |
| `--save-parser-errors-to`    | `<path>`            | Save sentences that caused parser errors.                             |
| `--save-invariant-errors-to` | `<path>`            | Save sentences that triggered syntactic‑invariant errors.             |
| `--save-comment-errors-to`   | `<path>`            | Save sentences that lost comments.                                    |
| `--save-internal-errors-to`  | `<path>`            | Save sentences that caused internal or “red‑herring” errors.          |
| `-v`                         | –                   | Increase verbosity (can be repeated).                                 |
| `--track-regressions-from`   | `<path>`            | Load failures from a previous run and detect regressions.             |
| `--track-regressions-to`     | `<path>`            | Save failures from current run.                                       |
| `--track-regressions-in`     | `<path>`            | Track failures accross runs. See **Continuous Integration**.          |

---  

## Output formats

### Normal mode (default)

Each line printed to **stdout** is a generated OCaml sentence. E.g.

```
let x = 42
```

If `--print-entrypoint` is set, the line looks like:

```
implementation: let x = 42
```

### Check mode

When `--ocamlformat-check` is enabled, four kinds of output are produced:

1. **Markdown report**. Written to `--save-report-to` (or stdout).  
   It contains sections for parser, lexer, comment, invariant, internal and
   red‑herring errors, each grouped by error message and by the most 
   frequent offending grammar item.  Sample failing sentences are shown.

2. **Categorised sentence files**. Optional files specified with the
   `--save-…-to` flags.  Each file contains one sentence per line, prefixed by
   the entrypoint `implementation:` or `interface:`.
   These can then be fed to the minidriver.

3. **Statistics printed on stderr**. A short summary of the number of
   successful formatings, syntax failures, comment drops, internal errors, …  

4. **Tracking regressions for continuous integration**. When
   `--track-regressions-in` is provided, failures are logged to a file and
   compared accross runs to detect regressions (sentences that could be
   formatted before but fail now). Up to `--max-report` regressions are printed
   and the exit code is set to 1 if at least one regression was detected.
   `--track-regressions-from` is used to only compare with a previous run and
   `--track-regressions-to` is used to only log failures from current run.

---  

## Check mode (ocamlformat integration)

```bash
ocamlgrammarfuzzer --ocamlformat-check \
    --exhaust --comments
    --save-report-to report.md \
    --save-lexer-errors-to lexer.txt \
    --save-parser-errors-to parser.txt
```

**What happens internally**

1. All sentences are generated (using the same algorithm as normal mode).  
2. Each sentence is passed to `ocamlformat`.
   For efficiency, sentences are batched and multiple instances are run in parallel 
   (controlled by `--jobs` and `--batch-size`).  
3. `ocamlformat` output is parsed, extracting the error message and location.  
4. Errors are classified. The report in `report.md` groups errors by:
   * error message,
   * grammar item (e.g. a particular production rule),
   * the concrete derivation that caused the failure (a sample sentence).  

**Internal errors and red-herrings**

`ocamlformat` may report no location or a location that does not belong to the
original input (e.g. a location in an intermediate file).  Those are classified
as *Internal error* (no location) or *Red‑herring* (invalid location). 

The report still tries to guess the offending construction.  This is done by
looking at the most common constructions in sentences that cause internal
errors.

---  

## Extending / custom grammars

The fuzzer comes with 4 builtin grammars: OCaml (default) and OxCaml (flag
`--oxcaml`), seen either as LALR (default) or LR(1) (flag `--lr1`) grammars.
The LALR grammars should be preferred; the LR(1) mode is provided for advanced uses. 

If you have a custom grammar, you can override the builtin ones with `--cmly`:

```bash
ocamlgrammarfuzzer --cmly my_ext.cmly --entrypoint my_ext_root
```

* The grammar must be compiled with Menhir’s `--cmly` flag to obtain the `.cmly`
  file.  
* The driver automatically extracts the list of terminal symbols; you can still
  override their printed representation with `--terminal`.
* For check mode, only `interface` and `implementation` entrypoints are 
  supported.

---  

## Pattern language

To control the generation, the `--avoid`, `--focus` and `--weight` flags take a
pattern that identify the syntactic constructions the flag applies to.

First, let's clarify the action of each flag:
- `--focus '<pattern>'` forces generation to produce enough sentences to cover all
  occurrences of `<pattern>` in the grammar.
- `--weight '<float> <pattern>'` changes the probability that a certain
  production is sampled by multiplying it with the provided weight.
- `--avoid '<pattern>'` is a shorthand for `--weight '0 <pattern>'`

By default, all productions have a weight of `1.0` (except those involving
the special symbol `error` which are always avoided).
The weights are interpreted locally: when attempting to generate a certain
non-terminal, the weights of all the productions of this non-terminal are summed
and one production is picked with a probability proportional to its weight. 

The pattern can be:
- A single symbol, e.g. `--avoid SEMISEMI`. All the productions in which this
  symbol occurs are affected.
- A rule `lhs: a b c...` with glob-like shorthands:
  - A symbol can be replaced by `_` to match any symbol, or `_*` to match any
    sequence of symbol. For instance, `expr: _*` matches all rules of `expr`.
  - The left-handside can be omitted or replaced by `_`; in this case, the set
    of rules with a matching right-handside is considered.
    `_: _* SEMISEMI _*` matches all rules involving a `SEMISEMI` (`;;`).
  - For focus only, one or more `.` can be inserted to identify the positions of
    interest, those on which to focus. For instance `expr: _* . PLUS _*` will
    generate sentences to cover all the way something on the left-side of a
    `PLUS` can be reduced.

---  

## Error classification

When reporting **ocamlformat** failures, the fuzzer classifies errors into up to six categories:

1. **Parser**  
2. **Lexer**
3. **Comment** 
4. **Invariant** 
5. **Internal** 
6. **Red herrings**

Because the fuzzer only has access to the output of **ocamlformat** and not to its internal state, the classification relies on heuristics that parse the output, mostly using the reported locations:

- **Lexer:** The rejection occurs in the middle of a token (**ocamlformat** recognized the token differently from the
  fuzzer expectation).
- **Parser:** A specific token causes the sentence to be rejected. (the token was recognized then rejected, but the fuzzer expects it to be correct).
- **Comment:** The error location points inside a comment; this is usually a comment that was dropped by formatting.
- **Invariant:** The error spans more than one token, typically produced by a semantic action in a production.
- **Internal:** **ocamlformat** was not able to produce a location.
- **Red herrings:** **ocamlformat** reported a non-sensical
  location. Matching the location to source code would be a dead end.

On top of this coarse-grained classification, the fuzzer groups errors by the grammatical construction surrounding the error location (represented by a grammatical item) and by the excerpt of the grammatical derivation that justifies the sentence’s validity.

### Sample report – parser error

**Item `seq_expr: . fun_seq_expr`** (in 2932 errors)

Derivation (182 occurrences):
  ```
  fun_expr: OVERWRITE ext list(attribute) . seq_expr WITH fun_expr
    seq_expr: . fun_seq_expr
      fun_seq_expr: . fun_expr
        fun_expr: . fun_
          fun_: . FUN ext list(attribute) fun_params optional_atomic_constraint_ MINUSGREATER fun_body
  ```

Sample sentence (implementation):
  ```ocaml
  overwrite_ fun false -> X with X
             ^^^
  ```

From this we learn that a `seq_expr` beginning with `FUN` is often rejected by **ocamlformat**, even though the grammar permits such a construction (via a few expansions: `seq_expr` -> `fun_seq_expr` -> `fun_expr` -> `fun_`). In this case it occurred after the `OVERWRITE` token, but a full report would contain other examples.

#### About invariant errors

Because the fuzzer is guided solely by the grammar, it can report errors for sentences that are syntactically valid but are rejected for semantic reasons.

Example:
`let x : type x . {%ext|s|} as 'x = X`
rejected with
`In this scoped type, variable 'x is reserved for the local type x.`

These errors may or may not be worth fixing in **ocamlformat**. Heuristics typically classify them as invariant errors to reduce noise in the report.

---  

## Continuous integration

The `--track-regressions-in` argument is designed to help fuzzing in a CI job. It uses a file, say `fuzzer_state.dat`, to remember the sentences that are known to fail and to detect regressions accross multiple runs.

In the CI workflow, running the fuzzer with this flag and reporing a non-zero exit code is sufficient to detect regressions:

The developer can then find some sample sentences that were previously accepted and are now failing in the output log.
They can either fix the problem or commit the new `fuzzer_state.dat` to silence these issues in the future. 

Sample use:

Running the fuzzer:
``` bash
ocamlgrammarfuzzer --ocamlformat-check --oxcaml --exhaust --comments --ocamlformat _build/default/bin/ocamlformat/main.exe --track-regressions-in fuzzer_state.dat
```

Use the new state for future reference:
``` bash
git add fuzzer_state.dat
# and/or dune promote if applicable
```

Dune does not support using a single file as input and as output, so it is better to use two different files and explicitly promote the output:

``` bash
ocamlgrammarfuzzer --ocamlformat-check --oxcaml --exhaust --comments 
                   --ocamlformat _build/default/bin/ocamlformat/main.exe 
                   --track-regressions-from fuzzer_state.dat 
                   --track-regressions-to fuzzer_state_new.dat
```

Updating the state can be done both to ignore some regressions that were reported, or, when more sentences succeed, to make future tests stricter.

TODO: if there are no regressions, the CI will pass; however it is still important to commmit the new `fuzzer_state.dat` to prevent future regressions. 
TODO: add a flag to write a detailed report on the regressions.

### CI and grammar updates

The state file is specific to a grammar version. When used with a different grammar, the fuzzer will detect the change and not report any regression. The state is still updated and can be committed. 

---  

## Mini-driver

`ocamlgrammarfuzzer-minidriver` is a minimal driver for `ocamlformat` that contains the checking logic but not the fuzzing logic.

It reads a list of sentences, one per line, and batches call to `ocamlformat`.

It can be used to quickly iterate on a known list of problematic sentences (such as those produced by the `--save-…-errors-to` options).

```bash
$ ocamlgrammarfuzzer -- --count 10 --length 10 --print-entrypoint --entrypoint implementation > sentences.lst
$ ocamlgrammarfuzzer-minidriver sentences.lst --ocamlformat _build/default/bin/ocamlformat/main.exe
line 000002: error: line 1.10-13: Error: Syntax error
line 000006: error: line 1.8-11: Error: Syntax error
line 000008: error: line 2.0-0: Error: Syntax error
```

---  

## Known limitations & TODOs

* **Invariant errors** are not problems of OCamlformat per se, but limitations
  of grammar-based fuzzing. Finer-grained control over the generation could help
  avoiding generating problematic sentences.
* **Error classification** depends on heuristics tuned to produce a useful
  classification. Don't hesitate to share ideas that could improve the process.
* **Error‑message parsing** is hard-coded to match the behavior of
  `ocamlformat`; if its output were to change, the parser will need to be updated.
* **Sensitivity to changes**. The fuzzing process is very sensitive to changes
  to the grammar. Even with a fixed seed, the set of sentences produced can
  change completely when the grammar is updated.
  We could tackle that to some extent in the future, but for reproducible
  processes, we suggest to use deterministic generation (`--exhaust`) and to
  store the generated sentences.
* **Biased generation**. The algorithm used for generating sentences is correct
  but not uniform (in particular, it is not a
  [Boltzmann sampler](https://en.wikipedia.org/wiki/Boltzmann_sampler)).
  We tried to use uniform generation but it is both (1) computationnally
  intensive and (2) not that useful for our use-cases (it is more
  valuable to favor difficult syntactic constructions).
* **Coverage of lexer specification**. The fuzzer stresses the syntax but has
  only minimal knowledge of the lexical conventions of OCaml. It is not
  sufficient to detect errors due to whitespaces (such as unexpected line
  returns), repeated comments, doc strings etc.

---  

## License

`ocamlgrammarfuzzer` is released under the **MIT License**.  See the `LICENSE` file in the
repository for the full text.  

---  

*Happy fuzzing!*  

*If you find a bug or have a feature request, please open an issue on the
GitHub repository.*  
