# OCaml Grammar Fuzzer

> **ocamlgrammarfuzzer** is a random‑sentence generator for the OCaml (and OxCaml) grammar.
> It can be used to stress‑test tools such as **ocamlformat**, the OCaml parser, or any
> downstream program that consumes OCaml source code.

The tool ships a built‑in grammar for the standard OCaml language, a grammar for
the OxCaml dialect, and also supports loading a grammar from a `.cmly` file
generated by Menhir.  Sentences can be printed directly, or they can be checked
against `ocamlformat` to obtain a detailed classification of failures.

---  

## Overview

The core algorithm builds grammatical *derivations* on a Menhir automaton.

The generation can be controlled:
* **Focused generation** – `--focus` lets you bias the generator toward
  particular grammatical constructions.
* **Avoid / weight** – Use `--avoid` to forbid productions and `--weight`
  to increase or decrease their probability.
* **Exhaustive mode** – With `--exhaust` the fuzzer enumerates a
  deterministic set that covers *all* reachable productions
  (subject to weight > 0).
* **Comments** – Fake comments can be inserted (`--comments`).

By default, the sentences are simply printed, but in *check mode* 
(`--ocamlformat-check`) they are fed to `ocamlformat`.  Failures are classified as lexer errors, syntax errors, comment handling errors, invariant errors (when rejected by semantic actions), and internal errors. See **Error classification**.

---  

## Installation 

TODO: add opam package

``` bash
opam pin add ocamlgrammarfuzzer https://github.com/shogan-ai/ocamlgrammarfuzzer.git 
```

## Building from sources

The project is a standard OCaml executable. It depends on `dune` for building, `menhir` for loading grammars and, at runtime, on the `ocamlformat` binary in **check mode**.

```bash
# Get the source
git clone https://github.com/shogan-ai/ocamlgrammarfuzzer.git
cd ocamlgrammarfuzzer
# Build the executable
dune build ocamlgrammarfuzzer
```

## Running the fuzzer

When installed, the executable is called `ocamlgrammarfuzzer`.
The most basic invocation prints a single sentence:

```bash
$ ocamlgrammarfuzzer
let x = 42
```

### Typical usage patterns

* **Generate many sentences**

  ```bash
  ocamlgrammarfuzzer --count 500 --length 120
  ```
  produce 500 sentences (one per line) of at most 120 tokens each (by default, 1 sentence of at most 100 tokens).

* **Target a specific entry point** (e.g. to generate only .mli files)

  ```bash
  ocamlgrammarfuzzer --entrypoint interface --count 200
  ```

* **Add fake comments** (useful when testing comment handling)

  ```bash
  ocamlgrammarfuzzer --comments --count 100
  ```

* **Control randomness**

  ```bash
  ocamlgrammarfuzzer --seed 42 --count 50
  ```

* **Focus on a pattern**

  ```bash
  ocamlgrammarfuzzer --focus "seq_expr" # generate enough sentences to cover all situations in which `seq_expr` appears
  ```

* **Avoid a construction**

  ```bash
  ocamlgrammarfuzzer --avoid 'let_binding_body: val_ident'  # avoid the punned let construction
  ```

* **Exhaustive enumeration** (deterministic, produce a huge number of sentences, `--count` is ignored)

  ```bash
  ocamlgrammarfuzzer --exhaust
  ```

* **Use a custom grammar**

  ```bash
  ocamlgrammarfuzzer --cmly my_grammar.cmly # ignore if you provide a .cmly file
  ```

---  

## Command‑line options

Below is the complete list (the driver file already contains the help strings).

| Option | Argument | Meaning |
|--------|----------|---------|
| `--count` | `<int>` | Number of sentences to generate (default = 1). |
| `--length` | `<int>` | Approximate number of tokens per sentence (default = 100). |
| `--seed` | `<int>` | Random seed (default = system time). |
| `--entrypoint` | `<symbol>` | Generate sentences starting from this non‑terminal. |
| `--weight` | `<float> <pattern>` | Multiply the weight of productions matching `<pattern>` by `<float>`. |
| `--avoid` | `<pattern>` | Set weight = 0 for productions matching `<pattern>`. |
| `--focus` | `<pattern>` | Bias generation toward productions matching `<pattern>`. |
| `--exhaust` | – | Deterministic exhaustive generation (ignores `--count`). |
| `--ocamlformat` | `<path>` | Customize ocamlformat command to use in check mode. |
| `--oxcaml` | – | Use the OxCaml dialect instead of the standard OCaml grammar. | – | 
| `--lr1` | – | Interpret builtin grammars as LR(1) instead of LALR. |
| `--cmly` | `<path.cmly>` | Load a grammar from a Menhir `.cmly` file. |
| `--comments` | – | Insert fake comments in the generated code. |
| `--print-entrypoint` | – | When printing, prefix each sentence with the entrypoint name. |
| `--terminal` | `<NAME>=<TEXT>` | Override the printed text for a terminal symbol. |
| `--jobs` | `<int>` | Parallel `ocamlformat` processes (default = 8). |
| `--batch-size` | `<int>` | Number of files per `ocamlformat` batch (default = 400). |
| `--ocamlformat-check` | – | Run in *check mode* (see below). |
| `--save-report-to` | `<path>` | Where to write the Markdown report (default = stdout). |
| `--max-report` | `<int>` | Maximum derivations per error message (default = 20). |
| `--save-successful-to` | `<path>` | Save successful sentences (no errors) to a file. |
| `--save-lexer-errors-to` | `<path>` | Save sentences that caused lexer errors. |
| `--save-parser-errors-to` | `<path>` | Save sentences that caused parser errors. |
| `--save-invariant-errors-to` | `<path>` | Save sentences that triggered syntactic‑invariant errors. |
| `--save-comment-errors-to` | `<path>` | Save sentences that lost comments. |
| `--save-internal-errors-to` | `<path>` | Save sentences that caused internal or “red‑herring” errors. |
| `-v` | – | Increase verbosity (can be repeated). |
| `--track-regressions-in` | `<path>` | When checking, save success state in a file (in a custom text format). If the file already exists, results of the current run are compared to it. If a regression is detected, exit code is set to 1. Finally, the file is updated with the current state. |

---  

## Output formats

### Normal mode (default)

Each line printed to **stdout** is a generated OCaml sentence. E.g.

```
let x = 42
```

If `--print-entrypoint` is set, the line looks like:

```
implementation: let x = 42
```

### Check mode

When `--ocamlformat-check` is enabled, four kinds of output are produced:

1. **Markdown report**. Written to `--save-report-to` (or stdout).  
   It contains sections for parser, lexer, comment, invariant, internal and
   red‑herring errors, each grouped by error message and by the most 
   frequent offending grammar item.  Sample failing sentences are shown.

2. **Categorised sentence files**. Optional files specified with the
   `--save-…-to` flags.  Each file contains one sentence per line, prefixed by
   the entrypoint `implementation:` or `interface:`.
   These can then be fed to the minidriver.

3. **Statistics printed on stderr**. A short summary of the number of
   successful formatings, syntax failures, comment drops, internal errors, …  

4. **Tracking regressions for continuous integration**. When
   `--track-regressions-in` is provided, failures are logged to a file and
   compared accross runs to detect regressions (sentences that could be
   formatted before but fail now). Up to `--max-report` regressions are printed
   and the exit code is set to 1 if at least one regression was detected.

---  

## Check mode (ocamlformat integration)

```bash
ocamlgrammarfuzzer --ocamlformat-check \
    --exhaust --comments
    --save-report-to report.md \
    --save-lexer-errors-to lexer.txt \
    --save-parser-errors-to parser.txt
```

**What happens internally**

1. All sentences are generated (using the same algorithm as normal mode).  
2. Each sentence is passed to `ocamlformat`.
   For efficiency, sentences are batched and multiple instances are run in parallel 
   (controlled by `--jobs` and `--batch-size`).  
3. `ocamlformat` output is parsed, extracting the error message and location.  
4. Errors are classified. The report in `report.md` groups errors by:
   * error message,
   * grammar item (e.g. a particular production rule),
   * the concrete derivation that caused the failure (a sample sentence).  

**Internal errors and red-herrings**

`ocamlformat` may report no location or a location that does not belong to the
original input (e.g. a location in an intermediate file).  Those are classified
as *Internal error* (no location) or *Red‑herring* (invalid location). 

The report still tries to guess the offending construction.  This is done by
looking at the most common constructions in sentences that cause internal
errors.

---  

## Extending / custom grammars

If you have a Menhir grammar for a language extension, you can feed it directly:

```bash
ocamlgrammarfuzzer --cmly my_ext.cmly --entrypoint my_ext_root
```

* The grammar must be compiled with Menhir’s `--cmly` flag to obtain the `.cmly`
  file.  
* The driver automatically extracts the list of terminal symbols; you can still
  override their printed representation with `--terminal`.
* For check mode, only `interface` and `implementation` entrypoints are 
  supported.

---  

## Pattern language

To control the generation, the `--avoid`, `--focus` and `--weight` flags take a
pattern that identify the syntactic constructions the flag applies to.

First, let's clarify the action of each flag:
- `--focus '<pattern>'` forces generation to produce enough sentences to cover all
  occurrences of `<pattern>` in the grammar.
- `--weight '<float> <pattern>'` changes the probability that a certain
  production is sampled by multiplying it with the provided weight.
- `--avoid '<pattern>'` is a shorthand for `--weight '0 <pattern>'`

By default, all productions have a weight of `1.0` (except those involving
the special symbol `error` which are always avoided).
The weights are interpreted locally: when attempting to generate a certain
non-terminal, the weights of all the productions of this non-terminal are summed
and one production is picked with a probability proportional to its weight. 

The pattern can be:
- A single symbol, e.g. `--avoid SEMISEMI`. All the productions in which this
  symbol occurs are affected.
- A rule `lhs: a b c...` with glob-like shorthands:
  - A symbol can be replaced by `_` to match any symbol, or `_*` to match any
    sequence of symbol. For instance, `expr: _*` matches all rules of `expr`.
  - The left-handside can be omitted or replaced by `_`; in this case, the set
    of rules with a matching right-handside is considered.
    `_: _* SEMISEMI _*` matches all rules involving a `SEMISEMI` (`;;`).
  - For focus only, one or more `.` can be inserted to identify the "positions
    of interest" which should be focused on. For instance `expr: _* . PLUS _*`
    will generate sentences to cover all the way something on the left-side of a
    `PLUS` can be reduced.

---  


## Error classification

TODO.

---  

## Mini-driver

TODO.

---  

## Known limitations & TODOs

* **Invariant errors** are not problems of OCamlformat per se, but limitations
  of grammar-based fuzzing. Finer-grained control over the generation could help
  avoiding generating problematic sentences.
* **Error classification** depends on heuristics tuned to produce a useful
  classification. Don't hesitate to share ideas that could improve the process.
* **Exhaustive mode can explode**. The number of reachable productions may be
  huge; memory consumption grows significantly with the size of the LR
  automaton.
  For reference, OxCaml's grammar of september 2025 tranlates to ~1M test sentences.
* **Error‑message parsing** is hard-coded to match the behavior of
  `ocamlformat`; if its output were to change, the parser will need to be updated.
* **Sensitivity to changes**. The fuzzing process is very sensitive to changes
  to the grammar. Even with a fixed seed, the set of sentences produced can
  change completely when the grammar is updated.
  We could tackle that to some extent in the future, but for reproducible
  processses, we suggest to use deterministic generation (`--exhaust`) and to
  store the generated sentences.
* **Biased generation**. The algorithm used for generating sentences is correct
  but not uniform (in particular, it is not a
  [Boltzmann sampler](https://en.wikipedia.org/wiki/Boltzmann_sampler)).
  We tried to use uniform generation but it is both (1) computationnally
  intensive and (2) not that useful for our use-cases (it is more
  valuable to favor difficult syntactic constructions).

---  

## License

`ocamlgrammarfuzzer` is released under the **MIT License**.  See the `LICENSE` file in the
repository for the full text.  

---  

*Happy fuzzing!*  

*If you find a bug or have a feature request, please open an issue on the
GitHub repository.*  
