# üî•ocamlgrammarfuzzerüî• - OCaml Syntax Fuzzer

> **ocamlgrammarfuzzer** is a random‚Äësentence generator for the OCaml (and Oxcaml) grammar.  
> It can be used to stress‚Äëtest tools such as **ocamlformat**, the OCaml parser, or any
> downstream program that consumes OCaml source code.

The tool ships a built‚Äëin grammar for the standard OCaml language, a grammar for
the Oxcaml dialect, and also supports loading a grammar from a `.cmly` file
generated by Menhir.  Sentences can be printed directly, or they can be checked
against `ocamlformat` to obtain a detailed classification of failures.

---  

## Overview

* **Generation** ‚Äì The core algorithm builds *derivations* on the Menhir grammar
  using a reachability analysis that respects optional weight specifications.
* **Focused generation** ‚Äì `--focus` lets you bias the generator toward
  particular grammatical constructions.
* **Avoid / weight** ‚Äì Use `--avoid` to forbid productions and `--weight` to
  increase or decrease their probability.
* **Exhaustive mode** ‚Äì With `--exhaust` the fuzzer enumerates a deterministic set
  that covers *all* reachable productions (subject to weight > 0).
* **Comments** ‚Äì Fake comments can be inserted (`--comments`).
* **Ocamlformat checking** ‚Äì In *check mode* (`--ocamlformat-check`) each generated
  sentence is fed to `ocamlformat`.  Failures are classified as
  lexer errors, syntax errors, comment handling errors, syntactic invariant errors, and internal (includeing "red herring") errors.
  See **Error classification**.

---  

## Installation & Building

The project is a standard OCaml executable that depends on:

| Dependency | Reason |
|------------|--------|
| `menhir` (`menhirSdk`) | Grammar loading / reachability analysis |
| `ocamlformat` binary (optional) | Used only in **check mode** |

### Getting the source

```bash
git clone https://github.com/shogan.ai/ocamlgrammarfuzzer.git
cd ocamlgrammarfuzzer
```

### Building

The project uses **dune**.  A simple build works with the default OCaml compiler
installed on your machine.

```bash
# Build the executable
dune build ./bin/main.exe
```

## Running the fuzzer

When installed, the executable is called `ocamlgrammarfuzzer`.
The most basic invocation prints a single sentence:

```bash
$ ./_build/default/bin/main.exe
let x = 42
```

### Typical usage patterns

* **Generate many sentences**

  ```bash
  ocamlgrammarfuzzer --count 500 --length 120
  ```
  produce 500 sentences of around 120 tokens each (by default, 1 sentence of 100 tokens).

* **Target a specific entry point** (e.g. to generate only .mli files)

  ```bash
  ocamlgrammarfuzzer --entrypoint interface --count 200
  ```

* **Add fake comments** (useful when testing comment handling)

  ```bash
  ocamlgrammarfuzzer --comments --count 100
  ```

* **Control randomness**

  ```bash
  ocamlgrammarfuzzer --seed 42 --count 50
  ```

* **Focus on a pattern**

  ```bash
  ocamlgrammarfuzzer --focus "seq_expr" # generate enough sentences to cover all situations in which `seq_expr` appears
  ```

* **Avoid a construction**

  ```bash
  ocamlgrammarfuzzer --avoid 'let_binding_body: val_ident'  # avoid the punned let construction
  ```

* **Exhaustive enumeration** (deterministic, may take a while)

  ```bash
  ocamlgrammarfuzzer --exhaust --count 0   # count is ignored in exhaust mode
  ```

* **Use a custom grammar**

  ```bash
  ocamlgrammarfuzzer --cmly my_grammar.cmly # ignore if you provide a .cmly file
  ```

---  

## Command‚Äëline options

Below is the complete list (the driver file already contains the help strings).

| Option | Argument | Meaning |
|--------|----------|---------|
| `--count` | `<int>` | Number of sentences to generate (default‚ÄØ=‚ÄØ1). |
| `--length` | `<int>` | Approximate number of tokens per sentence (default‚ÄØ=‚ÄØ100). |
| `--seed` | `<int>` | Random seed (default‚ÄØ=‚ÄØsystem time). |
| `--entrypoint` | `<symbol>` | Generate sentences starting from this non‚Äëterminal. |
| `--weight` | `<float> <pattern>` | Multiply the weight of productions matching `<pattern>` by `<float>`. |
| `--avoid` | `<pattern>` | Set weight‚ÄØ=‚ÄØ0 for productions matching `<pattern>`. |
| `--focus` | `<pattern>` | Bias generation toward productions matching `<pattern>`. |
| `--exhaust` | ‚Äì | Deterministic exhaustive generation (ignores `--count`). |
| `--oxcaml` | ‚Äì | Use the Oxcaml dialect instead of the standard OCaml grammar. |
| `--cmly` | `<path.cmly>` | Load a grammar from a Menhir `.cmly` file. |
| `--comments` | ‚Äì | Insert fake comments in the generated code. |
| `--print-entrypoint` | ‚Äì | Prefix each sentence with the entrypoint name. |
| `--terminal` | `<NAME>=<TEXT>` | Override the printed text for a terminal symbol. |
| `--jobs` | `<int>` | Parallel `ocamlformat` processes (default‚ÄØ=‚ÄØ8). |
| `--batch-size` | `<int>` | Number of files per `ocamlformat` batch (default‚ÄØ=‚ÄØ400). |
| `--ocamlformat-check` | ‚Äì | Run in *check mode* (see below). |
| `--save-report-to` | `<path>` | Where to write the Markdown report (default‚ÄØ=‚ÄØstdout). |
| `--max-report` | `<int>` | Maximum derivations per error message (default‚ÄØ=‚ÄØ20). |
| `--save-successful-to` | `<path>` | Save successful sentences (no errors) to a file. |
| `--save-lexer-errors-to` | `<path>` | Save sentences that caused lexer errors. |
| `--save-parser-errors-to` | `<path>` | Save sentences that caused parser errors. |
| `--save-invariant-errors-to` | `<path>` | Save sentences that triggered syntactic‚Äëinvariant errors. |
| `--save-comment-errors-to` | `<path>` | Save sentences that lost comments. |
| `--save-internal-errors-to` | `<path>` | Save sentences that caused internal or ‚Äúred‚Äëherring‚Äù errors. |
| `-v` | ‚Äì | Increase verbosity (can be repeated). |

---  

## Output formats

### Normal mode (default)

Each line printed to **stdout** is a generated OCaml sentence.  
If `--print-entrypoint` is set, the line looks like:

```
implementation: let x = 42
```

### Check mode

When `--ocamlformat-check` is enabled, three kinds of output are produced:

1. **Markdown report**. Written to `--save-report-to` (or stdout).  
   It contains sections for parser, lexer, comment, invariant, internal and
   red‚Äëherring errors, each grouped by error message and by the most frequent
   offending grammar item.  Sample failing sentences are shown.

2. **Categorised sentence files**. Optional files specified with the
   `--save-‚Ä¶-to` flags.  Each file contains one sentence per line, prefixed by
   the entrypoint `implementation:` or `interface:`.
   These can then be fed to the minidriver.

3. **Statistics printed on stderr**. A short summary of the number of
   successful formatings, syntax failures, comment drops, internal errors, ‚Ä¶  

---  

## Check mode (ocamlformat integration)

```bash
ocamlgrammarfuzzer --ocamlformat-check \
    --count 200 \
    --save-report-to report.md \
    --save-lexer-errors-to lexer.txt \
    --save-parser-errors-to parser.txt
```

**What happens internally**

1. All sentences are generated (using the same algorithm as normal mode).  
2. Each sentence is passed to `ocamlformat`.
   For efficiency, sentences are batched and multiple instances are run in parallel 
   (controlled by `--jobs` and `--batch-size`).  
3. `ocamlformat` output is parsed, extracting the error message and location.  
4. Errors are classified.  
5. The report groups errors by:
   * error message,
   * grammar item (e.g. a particular production rule),
   * the concrete derivation that caused the failure (a sample sentence).  

**Internal errors and red-herrings**

`ocamlformat` may report no location or a location that does not belong to the
original input (e.g. a location in an intermediate file).  Those are classified
as *Internal error* (no location) or *Red‚Äëherring* (invalid location). 

The report still tries to guess the offending construction.  This is done by
looking at the most common constructions in sentences that cause internal
errors.

---  

## Extending / custom grammars

If you have a Menhir grammar for a language extension, you can feed it directly:

```bash
ocamlgrammarfuzzer --cmly my_ext.cmly --entrypoint my_ext_root
```

* The grammar must be compiled with Menhir‚Äôs `--cmly` flag to obtain the `.cmly`
  file.  
* The driver automatically extracts the list of terminal symbols; you can still
  override their printed representation with `--terminal`.
* For check mode, only `interface` and `implementation` entrypoints are 
  supported.

---  

## Pattern language

To control the generation, the `--avoid`, `--focus` and `--weight` flags take a
pattern that identify the syntactic constructions the flag applies to.

First, let's clarify the action of each flag:
- `--focus '<pattern>'` forces generation to produce enough sentences to cover all
  occurrences of `<pattern>` in the grammar.
- `--weight '<float> <pattern>'` changes the probability that a certain
  production is sampled by multiplying it with the provided weight.
- `--avoid '<pattern>'` is a shorthand for `--weight '0 <pattern>'`

By default, all productions have a weight of `1.0` (except those involving
the special symbol `error` which are always avoided).
The weights are interpreted locally: when attempting to generate a certain
non-terminal, the weights of all the productions of this non-terminal are summed
and one production is picked with a probability proportional to its weight. 

The pattern can be:
- A single symbol, e.g. `--avoid SEMISEMI`. All the productions in which this
  symbol occurs are affected.
- A rule `lhs: a b c...` with glob-like shorthands:
  - A symbol can be replaced by `_` to match any symbol, or `_*` to match any
    sequence of symbol. For instance, `expr: _*` matches all rules of `expr`.
  - The left-handside can be omitted or replaced by `_`; in this case, the set
    of rules with a matching right-handside is considered.
    `_: _* SEMISEMI _*` matches all rules involving a `SEMISEMI` (`;;`).
  - For focus only, one or more `.` can be inserted to identify the "positions
    of interest" which should be focused on. For instance `expr: _* . PLUS _*`
    will generate sentences to cover all the way something on the left-side of a
    `PLUS` can be reduced.

---  


## Error classification

TODO.

---  

## Mini-driver

TODO.

---  

## Known limitations & TODOs

* **Invariant errors** are not problems of OCamlformat per se, but limitations
  of grammar-based fuzzing. Finer-grained control over the generation could help
  avoiding generating problematic sentences.
* **Error classification** depends on heuristics tuned to produce a useful
  classification. Don't hesitate to share ideas that could improve the process.
* **Exhaustive mode can explode**. The number of reachable productions may be
  huge; memory consumption grows significantly with the size of the LR
  automaton.
  For reference, OxCaml's grammar of september 2025 tranlates to ~1M test sentences.
* **Error‚Äëmessage parsing** is hard-coded to match the behavior of
  `ocamlformat`; if its output were to change, the parser will need to be updated.
* **Sensitivity to changes**. The fuzzing process is very sensitive to changes
  to the grammar. Even with a fixed seed, the set of sentences produced can
  change completely when the grammar is updated.
  We could tackle that to some extent in the future, but for reproducible
  processses, we suggest to use deterministic generation (`--exhaust`) and to
  store the generated sentences.
* **Biased generation**. The algorithm used for generating sentences is correct
  but not uniform (in particular, it is not a
  [Boltzmann sampler](https://en.wikipedia.org/wiki/Boltzmann_sampler)).
  We tried to use uniform generation but it is both (1) computationnally
  intensive and (2) not that useful for our use-cases (it is more
  valuable to favor difficult syntactic constructions).

---  

## License

`ocamlgrammarfuzzer` is released under the **MIT License**.  See the `LICENSE` file in the
repository for the full text.  

---  

*Happy fuzzing!*  

*If you find a bug or have a feature request, please open an issue on the
GitHub repository.*  
